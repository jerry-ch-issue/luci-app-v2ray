#!/bin/sh /etc/rc.common
#
# Copyright 2019-2020 Xingwang Liao <kuoruan@gmail.com>
# Licensed to the public under the MIT License.
#

START=99
USE_PROCD=1

NAME=v2ray
CONFIG_FOLDER=/var/etc/$NAME

FILE_V2RAY_DNSMASQ=/tmp/dnsmasq.d/$NAME
FILE_V2RAY_DNSMASQ_CACHE=/tmp/$NAME.dnsmasq.cache
FILE_V2RAY_CHNROUTE=/var/etc/v2ray/chnroute.txt
FILE_V2RAY_CHNROUTE6=/var/etc/v2ray/chnroute6.txt

CORE=
CORE_VER=
XTLS_REALITY=

NFT_BIN=$(command -v nft)

NFT_SET=$(expr $(dnsmasq --version|head -n 1|awk -F " " '{printf $3}') \>= "2.87")	



IPSET_SRC_IGNORE_V4=v2ray_src_ignore_v4
IPSET_SRC_IGNORE_V6=v2ray_src_ignore_v6
IPSET_DST_PROXY_V4=v2ray_dst_proxy_v4
IPSET_DST_PROXY_V6=v2ray_dst_proxy_v6
IPSET_SRC_DIRECT_V4=v2ray_src_direct_v4
IPSET_DST_DIRECT_V4=v2ray_dst_direct_v4
IPSET_DST_DIRECT_V6=v2ray_dst_direct_v6

OUTBOUND_SERVERS_V4=
OUTBOUND_SERVERS_V6=

FAKEDNS_ENABLED=0

TRANSPARENT_PROXY_EXPECTED=0
TRANSPARENT_PROXY_PORT=
TRANSPARENT_PROXY_USE_TPROXY=
TRANSPARENT_PROXY_ADDITION=
TRANSPARENT_PROXY_IPV6=0
EXCLUDED_TCP_PORT=
EXCLUDED_UDP_PORT=
DNSMASQ_RESTART_EXPECTED=0

. /usr/share/libubox/jshn.sh

_log() {
	local level="$1" ; shift
	local msg="$@"
	logger -p "daemon.$level" -t "$NAME" "$msg"

	echo "[$level] $msg" >&2
}

_info() {
	_log "info" $@
}

_err() {
	_log "err" $@
}

get_value_from_json() {
	local json="$1"
	local key="$2"

	test -n "$json" || return

	local value=""

	local old_ns
	json_set_namespace "json_key" old_ns
	json_load "$json"
	json_get_var "$key" value
	json_cleanup
	json_set_namespace "$old_ns"

	echo "$value"
}

get_commands_from_json() {
	local json="$1"

	test -n "$json" || return

	jshn -r "$json" 2>/dev/null | grep -v "json_init"
}

get_file_content() {
	local filename="$1"

	test -n "$filename" || return
	test -r "/etc/v2ray/${filename}.txt" || return

	cat "/etc/v2ray/${filename}.txt" | grep -v "^$" | grep -v "^#"
}

append_server_ipv4() {
	local addr="$1"

	test -n "$addr" || return

	if [ -z "$OUTBOUND_SERVERS_V4" ] ; then
		OUTBOUND_SERVERS_V4="$addr"
	else
		local ipa
		for ipa in $OUTBOUND_SERVERS_V4 ; do
			if [ "$addr" = "$ipa" ] ; then
				return
			fi
		done

		OUTBOUND_SERVERS_V4="$(cat >&1 <<-EOF
			$OUTBOUND_SERVERS_V4
			$addr
		EOF
		)"
	fi
}

append_server_ipv6() {
	local addr="$1"

	test -n "$addr" || return

	if [ -z "$OUTBOUND_SERVERS_V6" ] ; then
		OUTBOUND_SERVERS_V6="$addr"
	else	
		local ipa
		for ipa in $OUTBOUND_SERVERS_V6 ; do
			if [ "$addr" = "$ipa" ] ; then
				return
			fi
		done
		OUTBOUND_SERVERS_V6="$(cat >&1 <<-EOF
			$OUTBOUND_SERVERS_V6
			$addr
		EOF
		)"
	fi
}

append_server_address() {
	local addr="$1"

	test -n "$addr" || return

	local ipv4
	for ipv4 in $(resolveip -4 -t 5 "$addr") ; do
		append_server_ipv4 "$ipv4"
	done

	local ipv6
	for ipv6 in $(resolveip -6 -t 5 "$addr") ; do
		append_server_ipv6 "$ipv6"
	done
}

v2ray_section_validate() {
	uci_validate_section "$NAME" "v2ray" "$1" \
		'enabled:bool:0' \
		'v2ray_file:string' \
		'asset_location:directory' \
		'mem_percentage:and(uinteger, max(100)):80' \
		'config_file:file' \
		'loglevel:or("debug", "info", "warning", "error", "none")' \
		'access_log:string' \
		'error_log:string' \
		'stats_enabled:bool:0' \
		'transport_enabled:bool:0' \
		'inbounds:list(uci("v2ray", "@inbound"))' \
		'outbounds:list(uci("v2ray", "@outbound"))'
}

dns_section_validate() {
	uci_validate_section "$NAME" "dns" "$1" \
		'enabled:bool:0' \
		'tag:string' \
		'default_client_ip:ipaddr' \
		'query_strategy:or("UseIP", "UseIPv4", "UseIPv6")' \
		'disable_cache:bool:0' \
		'disable_fallback:bool:0' \
		'disable_fallback_if_match:bool:0' \
		'fakedns_enabled:bool:0' \
		'hosts:list(string)' \
		'servers:list(uci("v2ray", "@dns_server"))'
}

dns_server_section_validate() {
	uci_validate_section "$NAME" "dns_server" "$1" \
		'dns_server_type:or("DoH", "fakedns", "localhost", "QUIC", "TCP", "UDP")' \
		'local_mode:bool:0' \
		'doh_provider:string' \
		'address:string' \
		'port:port' \
		'domains:list(string)' \
		'expect_ips:list(string)' \
		'skip_fallback:bool' \
		'client_ip:ipaddr'
}

routing_section_validate() {
	uci_validate_section "$NAME" "routing" "$1" \
		'enabled:bool:0' \
		'main_domain_matcher:or("mph", "linear")' \
		'domain_strategy:or("AsIs", "IPIfNonMatch", "IPOnDemand")' \
		'rules:list(uci("v2ray", "@routing_rule"))' \
		'balancers:list(uci("v2ray", "@routing_balancer"))'
}

routing_rule_section_validate() {
	uci_validate_section "$NAME" "routing_rule" "$1" \
		'domain_matcher:or("mph", "linear")' \
		'type:"field"' \
		'domain:list(string)' \
		'ip:list(string)' \
		'port:or(port, portrange)' \
		'network:list(or("tcp", "udp"))' \
		'source:list(string)' \
		'source_port:or(port,portrange)' \
		'user:list(string)' \
		'inbound_tag:list(string)' \
		'protocol:list(or("http", "tls", "bittorrent"))' \
		'attrs:string' \
		'outbound_tag:string' \
		'balancer_tag:string'
}

routing_balancer_section_validate() {
	uci_validate_section "$NAME" "routing_balancer" "$1" \
		'tag:string' \
		'selector:list(string)'
}

policy_section_validate() {
	uci_validate_section "$NAME" "policy" "$1" \
		'enabled:bool:0' \
		'levels:list(uci("v2ray", "@policy_level"))' \
		'system_stats_inbound_uplink:bool:0' \
		'system_stats_inbound_downlink:bool:0'
}

policy_level_section_validate() {
	uci_validate_section "$NAME" "policy_level" "$1" \
		'level:uinteger' \
		'handshake:uinteger:4' \
		'conn_idle:uinteger:300' \
		'uplink_only:uinteger:2' \
		'downlink_only:uinteger:5' \
		'stats_user_uplink:bool:0' \
		'stats_user_downlink:bool:0' \
		'buffer_size:uinteger'
}

reverse_section_validate() {
	uci_validate_section "$NAME" "reverse" "$1" \
		'enabled:bool:0' \
		'bridges:list(string)' \
		'portals:list(string)'
}

inbound_section_validate() {
	uci_validate_section "$NAME" "inbound" "$1" \
		'port:or(port, portrange, string)' \
		'listen:ipaddr' \
		'protocol:string' \
		's_dokodemo_door_address:host' \
		's_dokodemo_door_port:port' \
		's_dokodemo_door_network:list(or("tcp", "udp"))' \
		's_dokodemo_door_timeout:uinteger' \
		's_dokodemo_door_follow_redirect:bool:0' \
		's_dokodemo_door_user_level:uiterger' \
		's_http_account_user:string' \
		's_http_account_pass:string' \
		's_http_allow_transparent:bool:0' \
		's_http_timeout:uinteger' \
		's_http_user_level:uinteger' \
		's_mtproto_user_email:string' \
		's_mtproto_user_secret:string' \
		's_mtproto_user_level:uinteger' \
		's_shadowsocks_email:string' \
		's_shadowsocks_method:string' \
		's_shadowsocks_password:string' \
		's_shadowsocks_level:uinteger' \
		's_shadowsocks_ota:bool:0' \
		's_shadowsocks_network:list(or("tcp", "udp")):tcp' \
		's_socks_auth:or("noauth", "password")' \
		's_socks_account_user:string' \
		's_socks_account_pass:string' \
		's_socks_udp:bool:0' \
		's_socks_ip:host' \
		's_socks_user_level:uinteger' \
		's_vmess_client_id:string' \
		's_vmess_client_alter_id:and(uinteger, max(65535))' \
		's_vmess_client_email:string' \
		's_vmess_client_user_level:uinteger' \
		's_vmess_default_alter_id:and(uinteger, max(65535))' \
		's_vmess_default_user_level:uinteger' \
		's_vmess_detour_to:string' \
		's_vmess_disable_insecure_encryption:bool:0' \
		'ss_network:or("tcp", "grpc", "kcp", "ws", "h2", "domainsocket", "quic")' \
		'ss_security:or("none", "tls")' \
		'ss_tls_server_name:host' \
		'ss_tls_alpn:list(string)' \
		'ss_tls_allow_insecure:bool:0' \
		'ss_tls_allow_insecure_ciphers:bool:0' \
		'ss_tls_disable_system_root:bool:0' \
		'ss_tls_cert_usage:or("encipherment", "verify", "issue")' \
		'ss_tls_cert_fiile:string' \
		'ss_tls_key_file:string' \
		'ss_tcp_header_type:or("none", "http")' \
		'ss_tcp_header_request_version:string' \
		'ss_tcp_header_request_method:string:GET' \
		'ss_tcp_header_request_path:string' \
		'ss_tcp_header_request_headers:list(string)' \
		'ss_tcp_header_response_version:string' \
		'ss_tcp_header_response_status:string' \
		'ss_tcp_header_response_reason:string' \
		'ss_tcp_header_response_headers:list(string)' \
		'ss_kcp_mtu:and(min(576), max(1460))' \
		'ss_kcp_tti:and(min(10), max(100))' \
		'ss_kcp_uplink_capacity:uinteger' \
		'ss_kcp_downlink_capacity:uinteger' \
		'ss_kcp_congestion:bool:0' \
		'ss_kcp_read_buffer_size:uinteger' \
		'ss_kcp_write_buffer_size:uinteger' \
		'ss_kcp_header_type:or("none", "srtp", "utp", "wechat-video", "dtls", "wireguard")' \
		'ss_websocket_path:string' \
		'ss_websocket_headers:hostname' \
		'ss_grpc_service_name:string' \
		'ss_grpc_multi_mode:bool:0' \
		'ss_grpc_permit_without_stream:bool:0' \
		'ss_grpc_idle_timeout:and(min(10), uinteger)' \
		'ss_grpc_health_check_timeout:and(min(10), uinteger)' \
		'ss_grpc_initial_windows_size:and(min(0), max(524288))' \
		'ss_http_host:list(host)' \
		'ss_http_path:string' \
		'ss_domainsocket_path:string' \
		'ss_quic_security:or("aes-128-gcm", "chacha20-poly1305", "none")' \
		'ss_quic_key:string' \
		'ss_quic_header_type:or("none", "srtp", "utp", "wechat-video", "dtls", "wireguard")' \
		'ss_sockopt_tcp_fast_open:or("0", "1")' \
		'ss_sockopt_tproxy:or("redirect", "tproxy", "off")' \
		'tag:string' \
		'sniffing_enabled:bool:0' \
		'sniffing_dest_override:list(or("fakedns", "http", "tls", "quic", "fakedns+others"))' \
		'metadata_only:bool:0' \
		'domains_excluded:list(hostname)' \
		'metadata_only:bool:0' \
		'allocate_strategy:or("always", "random")' \
		'allocate_refresh:uinteger' \
		'allocate_concurrency:uinteger'
}

outbound_section_validate() {
	uci_validate_section "$NAME" "outbound" "$1" \
		'send_through:ipaddr' \
		'protocol:string' \
		'tag:string' \
		's_blackhole_reponse_type:or("none", "http")' \
		's_dns_network:or("tcp", "udp")' \
		's_dns_address:string' \
		's_dns_port:port' \
		's_dns_user_level:uinteger' \
		's_dns_non_ip_query:or("", "drop", "skip")' \
		's_freedom_domain_strategy:or("AsIs", "UseIP", "UseIPv4", "UseIPv6")' \
		's_freedom_redirect:string' \
		's_freedom_fragment_length:string' \
		's_freedom_fragment_interval:string' \
		's_freedom_fragment_packets:string' \
		's_freedom_user_level:uinteger' \
		's_http_address:host' \
		's_http_server_port:port' \
		's_http_account_user:string' \
		's_http_account_pass:string' \
		's_http_headers:list(string)' \
		's_loopback_inboundtag:string' \
		's_shadowsocks_email:string' \
		's_shadowsocks_address:host' \
		's_shadowsocks_port:port' \
		's_shadowsocks_method:string' \
		's_shadowsocks_password:string' \
		's_shadowsocks_level:uinteger' \
		's_shadowsocks_ota:bool:0' \
		's_socks_server_address:host' \
		's_socks_server_port:port' \
		's_socks_account_user:string' \
		's_socks_account_pass:string' \
		's_socks_user_level:uinteger' \
		's_trojan_address:host'\
		's_trojan_port:port'\
		's_trojan_password:string'\
		's_vless_address:host' \
		's_vless_port:port' \
		's_vless_user_id:string' \
		's_vless_user_encryption:or("none")' \
		's_vless_user_level:uinteger' \
		's_vmess_address:host' \
		's_vmess_port:port' \
		's_vmess_user_id:string' \
		's_vmess_user_alter_id:and(uinteger, max(65535))' \
		's_vmess_user_security:or("auto", "aes-128-gcm", "chacha20-poly1305", "none")' \
		's_vmess_user_level:uinteger' \
		's_wireguard_secret_key:string' \
		's_wireguard_address:or(ipaddr, cidr)' \
		's_wireguard_public_key:string' \
		's_wireguard_preshared_key:string' \
		's_wireguard_allowed_ips:or(ipaddr, cidr)' \
		's_wireguard_keep_alive:uinteger' \
		's_wireguard_endpoint:string' \
		's_wireguard_mtu:and(uinteger, min(1280), max(1420))' \
		's_wireguard_reserved_bytes:string' \
		'ss_network:or("tcp", "kcp", "grpc", "ws", "h2", "domainsocket", "quic")' \
		'ss_security:or("none", "tls", "xtls", "reality")' \
		's_xtls_flow:or("","xtls-rprx-direct", "xtls-rprx-direct-udp443", "xtls-rprx-origin", "xtls-rprx-origin-udp443", "xtls-rprx-splice", "xtls-rprx-splice-udp443", "xtls-rprx-vision", "xtls-rprx-vision-udp443")' \
		'ss_reality_public_key:string' \
		'ss_reality_server_name:host' \
		'ss_reality_short_id:string' \
		'ss_reality_spiderx:string' \
		'ss_reality_fingerprint:or("", "360", "android","chrome", "edge", "firefox", "ios", "random", "randomized", "safari", "qq")' \
		'ss_reality_show:bool:0' \
		'ss_tls_server_name:host' \
		'ss_tls_alpn:list(string)' \
		'ss_tls_allow_insecure:bool:0' \
		'ss_tls_allow_insecure_ciphers:bool:0' \
		'ss_tls_disable_system_root:bool:0' \
		'ss_tls_cert_usage:or("encipherment", "verify", "issue")' \
		'ss_tls_cert_fiile:string' \
		'ss_tls_key_file:string' \
		'ss_tcp_header_type:or("none", "http")' \
		'ss_tcp_header_request_version:string' \
		'ss_tcp_header_request_method:string' \
		'ss_tcp_header_request_path:string' \
		'ss_tcp_header_request_headers:list(string)' \
		'ss_tcp_header_response_version:string' \
		'ss_tcp_header_response_status:string' \
		'ss_tcp_header_response_reason:string' \
		'ss_tcp_header_response_headers:list(string)' \
		'ss_kcp_mtu:and(min(576), max(1460))' \
		'ss_kcp_tti:and(min(10), max(100))' \
		'ss_kcp_uplink_capacity:uinteger' \
		'ss_kcp_downlink_capacity:uinteger' \
		'ss_kcp_congestion:bool:0' \
		'ss_kcp_read_buffer_size:uinteger' \
		'ss_kcp_write_buffer_size:uinteger' \
		'ss_kcp_header_type:or("none", "srtp", "utp", "wechat-video", "dtls", "wireguard")' \
		'ss_websocket_path:string' \
		'ss_websocket_headers:hostname' \
		'ss_grpc_service_name:string' \
		'ss_grpc_multi_mode:bool:0' \
		'ss_grpc_permit_without_stream:bool:0' \
		'ss_grpc_idle_timeout:and(min(10), uinteger)' \
		'ss_grpc_health_check_timeout:and(min(10), uinteger)' \
		'ss_grpc_initial_windows_size:and(min(0), max(524288))' \
		'ss_http_host:list(host)' \
		'ss_http_path:string' \
		'ss_domainsocket_path:string' \
		'ss_quic_security:or("aes-128-gcm", "chacha20-poly1305", "none")' \
		'ss_quic_key:string' \
		'ss_quic_header_type:or("none", "srtp", "utp", "wechat-video", "dtls", "wireguard")' \
		'ss_sockopt_mark:uinteger' \
		'ss_sockopt_tcp_no_dellay:bool:0' \
		'ss_sockopt_tcp_congestion:string' \
		'ss_sockopt_dialer_proxy:string' \
		'ss_sockopt_domain_strategy:or("", "AsIs", "UseIP", "UseIPv4", "UseIPv6")' \
		'ss_sockopt_tcp_fast_open:or("0", "1")' \
		'stream_settings:string' \
		'proxy_settings_tag:string' \
		'mux_enabled:bool:0' \
		'mux_concurrency:and(integer, min(-1), max(1024)):8' \
		'xudp_concurrency:and(integer, min(-1), max(1024)):8' \
		'xudp_proxy_udp443:or("allow", "reject", "skip")'
}

add_v2ray_nftables_redirect_rules() {
	local ext_args="$1"
	local ext_args6="$2"
	local lan_devices="$3"
	local lan_ipaddrs="$4"
	local lan_ip6addrs="$5"
	local proxy_mode="$6"
	local port="$TRANSPARENT_PROXY_PORT"
	local addition="$TRANSPARENT_PROXY_ADDITION"
	
	$NFT_BIN -f - <<-EOF >/dev/null  
		table inet $NAME {
			chain tcp_prerouting { 
				type nat hook prerouting priority dstnat; policy accept;
				$(
					if [ -n "$lan_devices" ] ; then
						local devices	
						for device in $lan_devices ; do
							echo "iifname $device meta l4proto tcp counter jump v2ray_tcp_rules"
						done
					else
						echo "meta nfproto ipv4 meta l4proto tcp counter jump v2ray_tcp_rules"
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							echo "meta nfproto ipv6 meta l4proto tcp counter jump v2ray_tcp_rules"
						fi
					fi
				)
			}
			chain v2ray_tcp_rules {
				$(
					if [ -n "$EXCLUDED_TCP_PORT" ] ; then
						local etp
						for etp in $EXCLUDED_TCP_PORT; do
							echo "tcp sport $etp counter accept"
						done
					fi
				)
				meta l4proto tcp mark 0xff counter accept
				$(
					if [ "$FAKEDNS_ENABLED" = "1" ] ; then
						echo -e "ip daddr 192.18.0.0/15 meta l4proto tcp counter redirect to :$port\n \
							ip6 daddr fc00::/18 meta l4proto tcp counter redirect to :$port"
					fi
				)
				ip daddr @$IPSET_DST_DIRECT_V4 counter accept
				ip saddr @$IPSET_SRC_DIRECT_V4 counter accept
				ip6 daddr @$IPSET_DST_DIRECT_V6 counter accept
				meta nfproto ipv4 tcp $ext_args counter redirect to :$port
				$(
					if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
						echo "meta nfproto ipv6 tcp $ext_args6 counter redirect to :$port"
					fi
				)
			}
			chain tcp_output {
				type nat hook output priority filter; policy accept;
				counter jump v2ray_tcp_rules
			}
		}
	}
	EOF
	if [ -n "$addition" ] ; then
		ip rule add fwmark 1 table 100
		ip route add local default dev lo table 100
		if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
			ip -6 rule add fwmark 1 table 100
			ip -6 route add local default dev lo table 100
		fi
		$NFT_BIN -f - <<-EOF >/dev/null
			table inet $NAME {
				chain udp_prerouting {
					type filter	hook prerouting priority mangle; policy accept;
					$(
						if [ -n "$lan_devices" ] ; then
							local device
							for device in $lan_devices ; do
								echo "iifname $device meta l4proto udp counter jump v2ray_udp_rules"
							done
						fi
						echo "meta nfproto ipv4 meta l4proto udp counter jump v2ray_udp_rules"
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							echo "meta nfproto ipv6 meta l4proto udp counter jump v2ray_udp_rules"
						fi
					)
				}
				chain v2ray_udp_rules {
					meta mark 0xff counter accept
					$(
						if [ -n "$lan_ipaddrs" ] ; then
							local ipaddr
							for ipaddr in $lan_ipaddrs ; do
								echo "ip daddr $ipaddr udp dport 53 counter tproxy ip to :$port meta mark set 1"
							done
						fi
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							if [ -n "$lan_ip6addrs" ] ; then
								local ip6adr
								for ip6addr in $lan_ip6addrs ; do
									echo "ip6 daddr $ip6addr udp dport 53 counter tproxy ip6 to :$port meta mark set 1"
								done
							fi
						fi
						if [ "$FAKEDNS_ENABLED" = "1" ] ; then
							echo -e "ip daddr 192.18.0.0/15 meta l4proto udp counter tproxy ip to :$port meta mark set 1\n \
							ip6 daddr fc00::/18 meta l4proto udp counter tproxy ip6 to :$port meta mark set 1"
						fi
					)
							
					ip daddr @$IPSET_DST_DIRECT_V4 counter accept
					ip saddr @$IPSET_SRC_DIRECT_V4 counter accept
					ip6 daddr @$IPSET_DST_DIRECT_V6 counter accept
					
					$(
						if [ "$addition" = "udp" ] ; then
							echo "meta nfproto ipv4 udp $ext_args counter tproxy ip to :$port meta mark set 1"
							if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
								echo "meta nfproto ipv6 udp $ext_args6 counter tproxy ip6 to :$port meta mark set 1"
							fi
						fi
					)
				}
				chain udp_output {
					type nat hook output priority filter; policy accept;
					meta l4proto udp mark 0xff counter accept
					udp dport 53 counter meta mark set 1
					$(
						if [ -n "$EXCLUDED_UDP_PORT" ] ; then
							local eup
							for eup in $EXCLUDED_UDP_PORT ; do
								echo "udp sport $eup counter accept"
							done
						fi
					
						if [ "$FAKEDNS_ENABLED" = "1" ] ; then
							echo -e "ip daddr 192.18.0.0/15 meta l4proto udp mark set 1\n \
								ip6 daddr fc00::/18 meta l4proto udp mark set 1"
						fi
					)
					ip daddr @$IPSET_DST_DIRECT_V4 counter accept
					ip saddr @$IPSET_SRC_DIRECT_V4 counter accept
					ip6 daddr @$IPSET_DST_DIRECT_V6 counter accept
					$(
						if [ "$addition" = "udp" ] ; then
							echo "meta nfproto ipv4 udp $ext_args counter meta mark set 1"
							if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
								echo "meta nfproto iv6 udp $ext_args6 counter meta mark set 1"
							fi
						fi
					)
				}
			}
		EOF
	fi
}

add_v2ray_nftables_tproxy_rules() {
	local ext_args="$1"
	local ext_args6="$2"
	local lan_devices="$3"
	local lan_ipaddrs="$4"
	local lan_ip6addrs="$5"
	local proxy_mode="$6"
	local port="$TRANSPARENT_PROXY_PORT"
	local addition="$TRANSPARENT_PROXY_ADDITION"
	
	test -n "$port" || return

	ip rule add fwmark 1 table 100
	ip route add local default dev lo table 100
	if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
		ip -6 rule add fwmark 1 table 100
		ip -6 route add local default dev lo table 100
	fi

	$NFT_BIN -f -<<-EOF
		#!$NFT_BIN -f
		table inet $NAME {
			chain divert { 
				type filter hook prerouting priority mangle; policy accept; 
				meta l4proto tcp socket transparent 1 counter meta mark set 1 accept
				$(
					if [ -n "$lan_devices" ] ; then 
						local device 
						for device in $lan_devices ; do
							echo "iifname $device counter jump v2ray_rules"
						done
					fi
				)
				meta mark 1 counter jump v2ray_rules
			}
			chain v2ray_rules {
				meta mark 0xff counter return
				$(
					if [ -n "$addition" ] ; then
						if [ -n "$lan_ipaddrs" ] ; then
							local ipaddr
							for ipaddr in $lan_ipaddrs ; do
								echo "ip daddr $ipaddr udp dport 53 counter tproxy ip to :$port meta mark set 1"
							done
						fi
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							if [ -n "$lan_ip6addrs" ] ; then
								local ip6addr
								for ip6addr in $lan_ip6addrs ; do
									echo "ip6 daddr $ip6addr udp dport 53 counter tproxy ip6 to :$port meta mark set 1"
								done
							fi
						fi
					fi
					if [ "$FAKEDNS_ENABLED" = "1" ] ; then
						echo -e "ip daddr 192.18.0.0/15 meta l4proto { tcp, udp } tproxy ip to :$port meta mark set 1\n \
							ip6 daddr fc00::/18 meta l4proto { tcp, udp } tproxy ip6 to :$port meta mark set 1"
					fi
				)
				ip daddr @$IPSET_DST_DIRECT_V4 counter return
				ip saddr @$IPSET_SRC_DIRECT_V4 counter return
				ip6 daddr @$IPSET_DST_DIRECT_V6 counter return
				meta nfproto ipv4 tcp $ext_args counter tproxy ip to :$port meta mark set 1
				$(
					if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
						echo "meta nfproto ipv6 tcp $ext_args6 counter tproxy ip6 to :$port meta mark set 1"
					fi
				)
				$(
					if [ "$addition" = "udp" ] ; then
						echo "meta nfproto ipv4 udp $ext_args counter tproxy ip to :$port meta mark set 1"
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							echo "meta nfproto ipv6 udp $ext_args6 counter tproxy ip6 to :$port meta mark set 1"
						fi
					fi
				)
			}
			chain v2ray_output { 
				type route hook output priority mangle; policy accept; 
				meta mark 0xff counter accept
				$(
					if [ -n "$addition" ] ; then
						echo -e "udp dport 53 counter meta mark set 1"
					fi
					if  [ -n "$EXCLUDED_TCP_PORT" ] ; then
						local etp
						for etp in $EXCLUDED_TCP_PORT ; do
							echo "tcp sport $etp counter accept"
						done
					fi
					if [ -n "$EXCLUDED_UDP_PORT" ] ; then
						local eup
						for eup in $EXCLUDED_UDP_PORT ; do
							echo "udp sport $eup counter accept"
						done
					fi
				)
				$(
					if [ "$FAKEDNS_ENABLED" = "1" ] ; then
						echo -e "ip daddr 192.18.0.0/15 counter meta l4proto { tcp, udp } mark set 1\n \
							ip6 daddr fc00::/18 counter meta l4proto { tcp, udp } mark set 1" 
					fi 
				)
				ip daddr @$IPSET_DST_DIRECT_V4 counter accept
				ip saddr @$IPSET_SRC_DIRECT_V4 counter accept
				ip6 daddr @$IPSET_DST_DIRECT_V6 counter accept
				meta nfproto ipv4 tcp $ext_args counter meta mark set 1
				$(
					if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
						echo "meta nfproto ipv6 tcp $ext_args6 counter meta mark set 1"
					fi
					if [ "$addition" = "udp" ] ; then
						echo "meta nfproto ipv4 udp $ext_args" counter meta mark set 1
						if [ "x$TRANSPARENT_PROXY_IPV6" = "x1" ] ; then
							echo "meta nfproto ipv6 udp $ext_args6 counter meta mark set 1"
						fi
					fi
				)
			}
		}
	EOF
}

clear_v2ray_rules() {
	$NFT_BIN delete table inet v2ray 2>/dev/null 
	while ip rule del fwmark 1 lookup 100 2>/dev/null ; do true ; done
	while ip -6 rule del fwmark 1 lookup 100 2>/dev/null ; do true ; done
	ip route flush table 100 2>/dev/null
	ip -6 route flush table 100 2>/dev/null
	ip route del local 0.0.0.0/0 dev lo table 100 2>/dev/null
	ip -6 route del local ::/0 dev lo table 100 2>/dev/null
}

create_v2ray_ipset() {
	# https://en.wikipedia.org/wiki/Reserved_IP_addresses
	local reserved_v4="$(cat >&1 <<-EOF
		0.0.0.0/8
		10.0.0.0/8
		100.64.0.0/10
		127.0.0.0/8
		169.254.0.0/16
		172.16.0.0/12
		192.0.0.0/24
		192.0.2.0/24
		192.88.99.0/24
		192.168.0.0/16
		192.18.0.0/15
		198.51.100.0/24
		203.0.113.0/24
		224.0.0.0/4
		240.0.0.0/4
		255.255.255.255
	EOF
	)"

	local reserved_v6="$(cat >&1 <<-EOF
		::
		::/128
		::1/128
		::ffff:0:0/96
		::ffff:0:0:0/96
		64:ff9b::/96
		100::/64
		2001::/32
		2001:20::/28
		2001:db8::/32
		2002::/16
		fc00::/7
		fe80::/10
		ff00::/8
	EOF
	)"

	local outbound_v4="$OUTBOUND_SERVERS_V4"
	local outbound_v6="$OUTBOUND_SERVERS_V6"
	$NFT_BIN  -f -<<-EOF 
		#!$NFT_BIN -f
		table inet $NAME {
			set $IPSET_DST_DIRECT_V4 { 
				type ipv4_addr
				flags interval
				elements = { 
				$(
					if [ -z "$outbound_v4" ] ; then
						echo "$reserved_v4" | sed '$d' | sed 's/240\.0\.0\.0\/4/240\.0\.0\.0\-255\.255\.255\.255/' | sed '$!s/$/,/'
					else
						echo "$reserved_v4" | sed '$d' | sed 's/240\.0\.0\.0\/4/240\.0\.0\.0\-255\.255\.255\.255/' | sed 's/$/,/'
						echo "$outbound_v4" | sed '$!s/$/,/'
					fi
				)
				}
			} 
			set $IPSET_SRC_DIRECT_V4 { 
				type ipv4_addr
				flags interval 
			}
			set $IPSET_DST_PROXY_V4 {
				type ipv4_addr
				flags interval
			}
			set $IPSET_DST_DIRECT_V6 { 
				type ipv6_addr
				flags interval
				elements = { 
				$(
					if [ -z "$outbound_v6" ] ; then
						echo "$reserved_v6" | sed '1d' | sed '$!s/$/,/'
					else
						echo "$reserved_v6" | sed '1d' | sed 's/$/,/'
						echo "$outbound_v6" | sed '$!s/$/,/'
					fi
				)
				}
			}
			set $IPSET_DST_PROXY_V6 {
				type ipv6_addr
				flags interval
			}
		}
	EOF
}

init_rules_for_listfile() {
	local direct_list_dns="$1"
	local proxy_list_dns="$2"

	echo "# AUTO-GENERATED FILE. DO NOT MODIFY." >"$FILE_V2RAY_DNSMASQ_CACHE"

	# For direct list
	local direct_content
	direct_content="$(get_file_content "directlist")"

	if [ -n "$direct_content" ] ; then
		$NFT_BIN add element inet v2ray $IPSET_DST_DIRECT_V4 \
			{ $(echo "$direct_content" | grep -oE "[0-9]{1,3}(\.[0-9]{1,3}){3}(/[0-9]{1,2})?" | sed "$!s/$/,/") }
		$NFT_BIN add element inet v2ray $IPSET_DST_DIRECT_V6 \
			{ $(echo "$direct_content" | grep -oE "([0-9a-fA-F]{0,4}:){1,7}([0-9a-fA-F]){0,4}(/[0-9]{1,2})?" | sed "$!s/$/,/") }
	fi

	# For proxy list
	local proxy_content
	local proxy_dns
	test -n $proxy_list_dns && \
		proxy_dns=$(echo $proxy_list_dns | sed 's/#53//' 2>/dev/null)
	proxy_content="$(get_file_content "proxylist")"
	if [ -n "$proxy_content" ] ; then
		echo $proxy_dns >> $proxy_content
		local proxy_v4=$(echo "$proxy_content" | grep -oE "[0-9]{1,3}(\.[0-9]{1,3}){3}(/[0-9]{1,2})?")
		local proxy_v6=$(echo "$proxy_content" | grep -oE "([0-9a-fA-F]{0,4}:){1,7}([0-9a-fA-F]){0,4}(/[0-9]{1,2})?")
		if [ -n "$proxy_v4" ] ; then
			$NFT_BIN add element inet v2ray $IPSET_DST_PROXY_V4 \
				{ $(echo "$proxy_v4" | sed '$!s/$/,/' ) }
		fi
		if [ -n "$proxy_v6" ] ; then
			$NFT_BIN add element inet v2ray $IPSET_DST_PROXY_V6 \
				{ $(echo "$proxy_v6" | sed '$!s/$/,/' ) }
		fi
		if [ "$NFT_SET" = "1" ] ; then
			if [ -n "$proxy_list_dns" ] ; then
				echo "$proxy_content" | \
					grep -oE "([0-9a-zA-Z_-]+\.)+[a-zA-Z]{2,}$" | \
					sed "s|.*|server=/&/$proxy_list_dns\nnftset=/&/inet#v2ray#$IPSET_DST_PROXY_V4,inet#v2ray#$IPSET_DST_PROXY_V6|" \
					>>"$FILE_V2RAY_DNSMASQ_CACHE"
			else
				echo "$proxy_content" | \
					grep -oE "([0-9a-zA-Z_-]+\.)+[a-zA-Z]{2,}$" | \
					sed "s|.*|nftset=/&/inet#v2ray#$IPSET_DST_PROXY_V4,inet#v2ray#$IPSET_DST_PROXY_V6|" \
					>>"$FILE_V2RAY_DNSMASQ_CACHE"
			fi
		fi
	fi
  # For local devices outbound list
	local src_content
	src_content="$(get_file_content "srcdirectlist")"

	if [ -n "$src_content" ] ; then
		local src_v4=$(echo "$src_content" | grep -oE "[0-9]{1,3}(\.[0-9]{1,3}){3}(/[0-9]{1,2})?")
		if [ -n "$src_v4" ] ; then
			$NFT_BIN add element inet v2ray $IPSET_SRC_DIRECT_V4 \
			{ $(echo  "$src_v4" | sed '$!s/$/,/') }
		fi
	fi
}

gracefully_restart_dnsmasq() {
	if [ "x$DNSMASQ_RESTART_EXPECTED" = "x1" ] && [ -x "/etc/init.d/dnsmasq" ] ; then
		_info "Restarting dnsmasq..."
		/etc/init.d/dnsmasq restart >/dev/null 2>&1
		DNSMASQ_RESTART_EXPECTED=0
	fi
}

add_dns_settings() {
	local section="${1}_dns"
	local doh

	if ! dns_section_validate "$section" ; then
		_err "Invalid DNS config: $section, skip"
		return 1
	fi

	if [ "x$enabled" != "x1" ] ; then
		_info "DNS disabled: $section"
		return 0
	fi
	json_add_object "dns"

	test -n "$tag" && \
		json_add_string "tag" "$tag"
#	test -n "$client_ip" && \
#		json_add_string "clientIp" "$client_ip"
	if [ -n "$hosts" ] ; then
		json_add_object "hosts"

		local h
		for h in $hosts ; do
			local domain="$(echo "$h" | cut -d'|' -f1)"
			local ip_arr
			local OLD_IFS="$IFS"
			IFS="," 
			ip_arr="$(echo "$h" | cut -d'|' -f2)"
	
			if [ -n "$domain" ] && [ -n "$ip_arr" ] ; then
				json_add_array "$domain"
				local ip
				for ip in $ip_arr ; do
					json_add_string "" "$ip"
				done
				json_close_array
			fi
			IFS="$OLD_IFS"
		done

		json_close_object # hosts
	fi

	if [ -n "$servers" ] ; then
		json_add_array "servers"
		
		for ss in $servers ; do
			if dns_server_section_validate "$ss" ; then
				local address_key=""
				local dns_address=""
				local dns_port
				test -n "$port" && dns_port=":$port"
				local lc
				if [ "x$local_mode" = "x1" ] ; then
					lc="+local"
				else
					lc=""
				fi
				case "${dns_server_type}" in
					"fakedns")
						dns_address="fakedns"
						;;
					"localhost")
						dns_address="localhost"
						;;
					"DoH")
						dns_address="https${lc}://${doh_provider}/dns-query"
						;;
					"QUIC")
						dns_address="quic${lc}://${address}${dns_port}"
						;;
					"TCP")
						dns_address="tcp${lc}://${address}${dns_port}"
						;;
					"UDP")		
						dns_address=$address
						;;
				esac

			if [ "x$FAKEDNS_ENABLED" = "x0" ] ; then
				if [ -n "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
					json_add_object 
					address_key="address"
				fi
				case "$dns_server_type"  in
					"fakedns")
						json_add_string "${address_key}" "$dns_address"
						FAKEDNS_ENABLED=1
						;;
					"UDP")
						if [ -z "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
							if [ -n "$port" ] ;then
								json_add_object
								json_add_string "address" "$dns_address"
								json_add_int "port" "$port"
								json_close_object
							else
								json_add_string "${address_key}" "$dns_address"
							fi
						else
							json_add_string "${address_key}" "$dns_address"
						fi
						;;
					*)
						json_add_string "${address_key}" "$dns_address"
						;;
				esac
				if [ -n "$domains" ] ; then
					json_add_array "domains"
					local d
					for d in $domains ; do
						json_add_string "" "$d"
					done
					json_close_array # domains
				fi
				if [ -n "$expect_ips" ] ; then
					json_add_array "expectIPs"
					local e
					for e in $expect_ips ; do
						json_add_string "" "$e"
					done
					json_close_array # expectIPs
				fi
				test -n "$skip_fallback" &&	json_add_boolean "skipFallback" "$skip_fallback"
				test -n "$client_ip" && json_add_string "clientIp" "$client_ip"
				if [ -n "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
					json_close_object
				fi
			else
				case "${dns_server_type}" in
					"DoH"|"localhost"|"QUIC"|"TCP"|"UDP")
						if [ -n "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
							json_add_object 
							address_key="address"
						fi
						if [ "$dns_server_type" = "UDP" ] ; then
							if [ -z "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
								if [ -n "$port" ] ;then
									json_add_object
									json_add_string "address" "$dns_address"
									json_add_int "port" "$port"
									json_close_object
								
								else
									json_add_string "${address_key}" "$dns_address"
								fi
							else
								json_add_string "${address_key}" "$dns_address"
							fi
						else
							json_add_string "${address_key}" "$dns_address"
						fi
						if [ -n "$domains" ] ; then
							json_add_array "domains"
							local d
							for d in $domains ; do
								json_add_string "" "$d"
							done
							json_close_array # domains
						fi
						if [ -n "$expect_ips" ] ; then
							json_add_array "expectIPs"
							local e
							for e in $expect_ips ; do
								json_add_string "" "$e"
							done
							json_close_array # expectIPs
						fi
						test -n "$skip_fallback" &&	json_add_boolean "skipFallback" "$skip_fallback"
						test -n "$client_ip" && json_add_string "clientIp" "$client_ip"
						if [ -n "${domains}${expect_ips}${client_ip}${skip_fallback}" ] ; then
							json_close_object
						fi
						;;
					"fakedns")
						_err "Only 1 fakedns configuration can be enabled at the same time"
						;;
				esac
			fi
		fi
	done

	json_close_array # servers
	fi
	test -n "$default_client_ip" && json_add_string "clientIp" "$default_client_ip"
	json_add_string "queryStrategy" "$query_strategy"
	json_add_boolean "disableCache" "$disable_cache"
	json_add_boolean "disableFallback" "$disable_fallback"
	json_add_boolean "disableFallbackIfMatch" "$disable_fallback_if_match"

	json_close_object # dns
}

add_routing_settings() {
	local section="${1}_routing"

	if ! routing_section_validate "$section" ; then
		_err "Invalid routing config: $section, skip"
		return 1
	fi

	if [ "x$enabled" != "x1" ] ; then
		_info "Routing disabled: $section"
		return 0
	fi

	json_add_object "routing"
	
	test -n "$main_domain_matcher" && json_add_string "domainMatcher" "$main_domain_matcher"

	test -n "$domain_strategy" && \
		json_add_string "domainStrategy" "$domain_strategy"

	if [ -n "$rules" ] ; then
		json_add_array "rules"

		local rs
		for rs in $rules ; do
			if routing_rule_section_validate "$rs" ; then
				json_add_object ""
				
				test -n "$domain_matcher" && json_add_string "domainMatcher" "$domain_matcher"

				json_add_string "type" "$type"

				if [ -n "$domain" ] ; then
					json_add_array "domain"

					local d
					for d in $domain ; do
						json_add_string "" "$d"
					done

					json_close_array # domain
				fi

				if [ -n "$ip" ] ; then
					json_add_array "ip"

					local i
					for i in $ip ; do
						json_add_string "" "$i"
					done

					json_close_array # ip
				fi

				if [ -n "$port" ] ; then
					json_add_string "port" "$(echo "$port" | tr -s ' ' ',')"
				fi

				if [ -n "$network" ] ; then
					json_add_string "network" "$(echo "$network" | tr -s ' ' ',')"
				fi

				if [ -n "$source" ] ; then
					json_add_array "source"

					local s
					for s in $source ; do
						json_add_string "" "$s"
					done

					json_close_array # source
				fi

				if [ -n "$source_port" ] ; then
					json_add_string "sourcePort" "$(echo "$source_port" | tr -s ' ' ',')"
				fi

				if [ -n "$user" ] ; then
					json_add_array "user"

					local u
					for u in $user ; do
						json_add_string "" "$u"
					done

					json_close_array # user
				fi

				if [ -n "$inbound_tag" ] ; then
					json_add_array "inboundTag"

					local it
					for it in $inbound_tag ; do
						json_add_string "" "$it"
					done

					json_close_array # inboundTag
				fi

				if [ -n "$protocol" ] ; then
					json_add_array "protocol"
					local p
					for p in $protocol ; do
						json_add_string "" "$p"
					done
					json_close_array # protocol
				fi

				test -n "$attrs" && \
					json_add_string "attrs" "$attrs"
				test -n "$outbound_tag" && \
					json_add_string "outboundTag" "$outbound_tag"
				test -n "$balancer_tag" && \
					json_add_string "balancerTag" "$balancer_tag"

				json_close_object
			fi
		done

		json_close_array # rules
	fi

	if [ -n "$balancers" ] ; then
		json_add_array "balancers"

		local bs
		for bs in $balancers ; do
			if routing_balancer_section_validate "$bs" ; then
				json_add_object ""
				json_add_string "tag" "$tag"

				json_add_array "selector"

				local s
				for s in $selector ; do
					json_add_string "" "$s"
				done

				json_close_array # selector
				json_close_object
			fi
		done

		json_close_array # balancers
	fi

	json_close_object
}

add_policy_settings() {
	local section="${1}_policy"

	if ! policy_section_validate "$section" ; then
		_err "Invalid policy config: $section, skip"
		return 1
	fi

	if [ "x$enabled" != "x1" ] ; then
		_info "Policy disabled: $section"
		return 0
	fi

	json_add_object "policy"

	if [ -n "$levels" ] ; then
		json_add_object "levels"

		local l_s
		for l_s in $levels ; do
			if policy_level_section_validate "$l_s" ; then
				json_add_object "$level"
				json_add_int "handshake" "$handshake"
				json_add_int "connIdle" "$conn_idle"
				json_add_int "uplinkOnly" "$uplink_only"
				json_add_int "downlinkOnly" "$downlink_only"
				json_add_boolean "statsUserUplink" "$stats_user_uplink"
				json_add_boolean "statsUserDownlink" "$stats_user_downlink"
				test -n "$buffer_size" && \
					json_add_int "bufferSize" "$buffer_size"
				json_close_object
			fi
		done

		json_close_object # levels
	fi

	json_add_object "system"
	json_add_boolean "statsInboundUplink" "$system_stats_inbound_uplink"
	json_add_boolean "statsInboundDownlink" "$system_stats_inbound_downlink"
	json_close_object # system

	json_close_object # policy
}

add_reverse_settings() {
	local section="${1}_reverse"

	if ! reverse_section_validate "$section" ; then
		_err "Invalid reverse config: $section, skip"
		return 1
	fi

	if [ "x$enabled" != "x1" ] ; then
		_info "Reverse disabled: $section"
		return 0
	fi

	json_add_object "reverse"

	if [ -n "$bridges" ] ; then
		json_add_array "bridges"

		local b
		for b in $bridges ; do
			local tag="$(echo "$b" | cut -d'|' -f1)"
			local domain="$(echo "$b" | cut -d'|' -f2)"
			if [ -n "$tag" ] && [ -n "$domain" ] ; then
				json_add_object ""
				json_add_string "tag" "$tag"
				json_add_string "domain" "$domain"
				json_close_object
			fi
		done

		json_close_array # bridges
	fi

	if [ -n "$portals" ] ; then
		json_add_array "portals"

		local p
		for p in $portals ; do
			local tag="$(echo "$p" | cut -d'|' -f1)"
			local domain="$(echo "$p" | cut -d'|' -f2)"
			if [ -n "$tag" ] && [ -n "$domain" ] ; then
				json_add_object ""
				json_add_string "tag" "$tag"
				json_add_string "domain" "$domain"
				json_close_object
			fi
		done

		json_close_array # portals
	fi

	json_close_object # reverse
}

add_transport_settings() {
	local json
	json="$(get_file_content "transport")"

	if [ -z "$json" ] ; then
		_err "Invalid transport config: $key"
		return 1
	fi

	json_add_object "transport"
	eval "$(get_commands_from_json "$json")"
	json_close_object # transport
}

add_inbound_setting() {
	local section="$1"

	if ! inbound_section_validate "$section" ; then
		_err "Invalid inbound section: $section"
		return 1
	fi

	json_add_object ""

	test -n "$listen" && \
		json_add_string "listen" "$listen"
	json_add_int "port" "$port"
	json_add_string "protocol" "$protocol"

	case "${protocol:-x}" in
		"dokodemo-door")
			json_add_object "settings"

			if [ -n "$port" ] && [ "x$port" = "x$TRANSPARENT_PROXY_PORT" ] ; then
				local settings_network="tcp"

				test -n "$TRANSPARENT_PROXY_ADDITION" && \
					settings_network="$settings_network,udp"

				json_add_boolean "followRedirect" "1"
				json_add_string "network" "$settings_network"
			else
				test -n "$s_dokodemo_door_address" && \
					json_add_string "address" "$s_dokodemo_door_address"

				test -n "$s_dokodemo_door_port" && \
					json_add_int "port" "$s_dokodemo_door_port"

				test -n "$s_dokodemo_door_follow_redirect" && \
					json_add_boolean "followRedirect" "$s_dokodemo_door_follow_redirect"

				test -n "$s_dokodemo_door_network" && \
					json_add_string "network" "$(echo "$s_dokodemo_door_network" | tr -s ' ' ',')"
			fi

			test -n "$s_dokodemo_door_timeout" && \
				json_add_int "timeout" "$s_dokodemo_door_timeout"

			test -n "$s_dokodemo_door_user_level" && \
				json_add_int "userLevel" "$s_dokodemo_door_user_level"

			json_close_object # settings
			;;
		"http")
			json_add_object "settings"

			if [ -n "$s_http_account_user" ] ; then
				json_add_array "accounts"

				json_add_object ""
				json_add_string "user" "$s_http_account_user"
				json_add_string "pass" "$s_http_account_pass"
				json_close_object

				json_close_array # accounts
			fi

			json_add_boolean "allowTransparent" "$s_http_allow_transparent"

			test -n "$s_http_timeout" && \
				json_add_int "timeout" "$s_http_timeout"
			test -n "$s_http_user_level" && \
				json_add_int "userLevel" "$s_http_user_level"

			json_close_object # settings
			;;
		"loopback")
			json_add_object "settings"
			
			if [ -n "$s_loopback_inboundtag" ] ; then
				json_add_string "inboundTag" "$s_loopback_inboundtag"
			fi
			json_close_object
			;;
		"mtproto")
			json_add_object "settings"

			if [ -n "$s_mtproto_user_email" ] ; then
				json_add_array "users"
				json_add_object ""

				json_add_string "email" "$s_mtproto_user_email"
				json_add_string "secret" "$s_mtproto_user_secret"

				test -n "$s_mtproto_user_level" && \
					json_add_int "level" "$s_mtproto_user_level"

				json_close_object
				json_close_array # users
			fi

			json_close_object # settings
			;;
		"shadowsocks")
			json_add_object "settings"

			json_add_string "method" "$s_shadowsocks_method"
			json_add_string "password" "$s_shadowsocks_password"

			test -n "$s_shadowsocks_email" && \
				json_add_string "email" "$s_shadowsocks_email"
			test -n "$s_shadowsocks_level" && \
				json_add_int "level" "$s_shadowsocks_level"

			json_add_boolean "ota" "$s_shadowsocks_ota"
			json_add_string "network" "$(echo "$s_shadowsocks_network" | tr -s ' ' ',')"

			json_close_object # settings
			;;
		"socks")
			json_add_object "settings"

			json_add_string "auth" "$s_socks_auth"

			if [ -n "$s_socks_account_user" ] ; then
				json_add_array "accounts"
				json_add_object ""
				json_add_string "user" "$s_socks_account_user"
				json_add_string "pass" "$s_socks_account_pass"
				json_close_object
				json_close_array # accounts
			fi

			json_add_boolean "udp" "$s_socks_udp"

			test -n "$s_socks_ip" && \
				json_add_string "ip" "$s_socks_ip"
			test -n "$s_socks_user_level" && \
				json_add_int "userLevel" "$s_socks_user_level"

			json_close_object # settings
			;;
		"vmess")
			json_add_object "settings"

			if [ -n "$s_vmess_client_id" ] ; then
				json_add_array "clients"
				json_add_object ""

				json_add_string "id" "$s_vmess_client_id"

				test -n "$s_vmess_client_alter_id" && \
					json_add_int "alterId" "$s_vmess_client_alter_id"
				test -n "$s_vmess_client_email" && \
					json_add_string "email" "$s_vmess_client_email"
				test -n "$s_vmess_client_user_level" && \
					json_add_int "level" "$s_vmess_client_user_level"

				json_close_object
				json_close_array # clients
			fi

			json_add_object "default"

			test -n "$s_vmess_default_alter_id" && \
				json_add_int "alterId" "$s_vmess_default_alter_id"
			test -n "$s_vmess_default_user_level" && \
				json_add_int "level" "$s_vmess_default_user_level"

			json_close_object # default

			if [ -n "$s_vmess_detour_to" ] ; then
				json_add_object "detour"
				json_add_string "to" "$s_vmess_detour_to"
				json_close_object # detour
			fi

			json_add_boolean "disableInsecureEncryption" "$s_vmess_disable_insecure_encryption"

			json_close_object # settings
			;;
	esac

	json_add_object "streamSettings"

	test -n "$ss_network" && \
		json_add_string "network" "$ss_network"

	test -n "$ss_security" && \
		json_add_string "security" "$ss_security"

	if [ "x$ss_security" = "xtls" ] ; then
		json_add_object "tlsSettings"

		test -n "$ss_tls_server_name" && \
			json_add_string "serverName" "$ss_tls_server_name"

				if [ -n "$ss_tls_alpn" ] ; then
					json_add_array "alpn"
					local al
					for al in $ss_tls_alpn ; do
						json_add_string "" "$al"
					done
					json_close_array # destOverride
				fi

		json_add_boolean "allowInsecure" "$ss_tls_allow_insecure"
		json_add_boolean "allowInsecureCiphers" "$ss_tls_allow_insecure_ciphers"
		json_add_boolean "disableSystemRoot" "$ss_tls_disable_system_root"
		
		if [ -n "$ss_tls_cert_fiile" ] ; then
			json_add_array "certificates"
				json_add_object ""
				json_add_string "certificateFile" "$ss_tls_cert_fiile"
				json_add_string "keyFile" "$ss_tls_key_file"
				test -n "$ss_tls_cert_usage" && \
					json_add_string "usage" "$ss_tls_cert_usage"
				json_close_object
			json_close_array
		fi
		json_close_object # tlsSettings
	fi

	case "${ss_network:-x}" in
		"tcp")
			json_add_object "tcpSettings"

			if [ -n "$ss_tcp_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_tcp_header_type"

				if [ "$ss_tcp_header_type" = "http" ] ; then
					json_add_object "request"
					test -n "$ss_tcp_header_request_version" && \
						json_add_string "version" "$ss_tcp_header_request_version"
					json_add_string "method" "$ss_tcp_header_request_method"

					if [ -n "$ss_tcp_header_request_path" ] ; then
						json_add_array "path"
						json_add_string "" "$ss_tcp_header_request_path"
						json_close_array # path
					fi

					if [ -n "$ss_tcp_header_request_headers" ] ; then
						json_add_object "headers"

						handle_request_header() {
							local h="$1"

							local name="$(echo "$h" | cut -d'=' -f1)"
							local value="$(echo "$h" | cut -d'=' -f2)"

							if [ -n "$name" ] && [ -n "$value" ] ; then
								json_add_array "$name"
								json_add_string "" "$value"
								json_close_array
							fi
						}
						config_list_foreach "$section" "ss_tcp_header_request_headers" handle_request_header

						json_close_object # headers
					fi

					json_close_object # request

					json_add_object "response"

					test -n "$ss_tcp_header_response_version" && \
						json_add_string "version" "$ss_tcp_header_response_version"
					test -n "$ss_tcp_header_response_status" && \
						json_add_string "status" "$ss_tcp_header_response_status"
					test -n "$ss_tcp_header_response_reason" && \
						json_add_string "reason" "$ss_tcp_header_response_reason"

					if [ -n "$ss_tcp_header_response_headers" ] ; then
						json_add_object "headers"

						handle_response_header() {
							local h="$1"

							local name="$(echo "$h" | cut -d'=' -f1)"
							local value="$(echo "$h" | cut -d'=' -f2)"

							if [ -n "$name" ] && [ -n "$value" ] ; then
								json_add_array "$name"
								json_add_string "" "$value"
								json_close_array
							fi
						}
						config_list_foreach "$section" "ss_tcp_header_response_headers" handle_response_header

						json_close_object # headers
					fi

					json_close_object # response
				fi
				json_close_object # header
			fi

			json_close_object # tcpSettings
			;;
		"kcp")
			json_add_object "kcpSettings"

			test -n "$ss_kcp_mtu" && \
				json_add_int "mtu" "$ss_kcp_mtu"
			test -n "$ss_kcp_tti" && \
				json_add_int "tti" "$ss_kcp_tti"
			test -n "$ss_kcp_uplink_capacity" && \
				json_add_int "uplinkCapacity" "$ss_kcp_uplink_capacity"
			test -n "$ss_kcp_downlink_capacity" && \
				json_add_int "downlinkCapacity" "$ss_kcp_downlink_capacity"
			json_add_boolean "congestion" "$ss_kcp_congestion"
			test -n "$ss_kcp_read_buffer_size" && \
				json_add_int "readBufferSize" "$ss_kcp_read_buffer_size"
			test -n "$ss_kcp_write_buffer_size" && \
				json_add_int "writeBufferSize" "$ss_kcp_write_buffer_size"

			if [ -n "$ss_kcp_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_kcp_header_type"
				json_close_object # header
			fi

			json_close_object # kcpSettings
			;;
		"ws")
			json_add_object "wsSettings"

			test -n "$ss_websocket_path" && \
				json_add_string "path" "$ss_websocket_path"

			if [ -n "$ss_websocket_headers" ] ; then
				json_add_object "headers"
				json_add_string "Host" "$ss_websocket_headers"
#				handle_websocket_header() {
#					local h="$1"
#					local name="$(echo "$h" | cut -d'=' -f1)"
#					local value="$(echo "$h" | cut -d'=' -f2)"
#					if [ -n "$name" ] && [ -n "$value" ] ; then
#						json_add_string "$name" "$value"
#					fi
#				}
#				config_list_foreach "$section" "ss_websocket_headers" handle_websocket_header

				json_close_object # headers
			fi

			json_close_object # wsSettings
			;;
		"grpc")
			json_add_object "grpcSettings"

			test -n "$ss_grpc_service_name" && \
				json_add_string "serviceName" "$ss_grpc_service_name"
			json_add_boolean "multiMode" "$ss_grpc_multi_mode"
			json_add_boolean "permit_without_stream" "$ss_grpc_permit_without_stream"

			if [ "x$ss_grpc_permit_without_stream" = "x1" ] ; then
				test -n "$ss_grpc_health_check_timeout" && \
				json_add_int "health_check_timeout" "$ss_grpc_health_check_timeout"
			fi

			test -n "$ss_grpc_idle_timeout" && \
				json_add_int "idle_timeout" "$ss_grpc_idle_timeout"
			
			test -n "$ss_grpc_initial_windows_size" && \
				json_add_int "initial_windows_size" "$ss_initial_windows_size"
			json_close_object # wsSettings
			;;

		"h2")
			json_add_object "h2Settings"

			if [ -n "$ss_http_host" ] ; then
				json_add_array "host"

				local h
				for h in $ss_http_host ; do
					json_add_string "" "$h"
				done

				json_close_array # host
			fi

			test -n "$ss_http_path" && \
				json_add_string "path" "$ss_http_path"

			json_close_object # httpSettings
			;;
		"domainsocket")
			json_add_object "dsSettings"

			test -n "$ss_domainsocket_path" && \
				json_add_string "path" "$ss_domainsocket_path"

			json_close_object # dsSettings
			;;
		"quic")
			json_add_object "quicSettings"

			test -n "$ss_quic_security" && \
				json_add_string "security" "$ss_quic_security"
			test -n "$ss_quic_key" && \
				json_add_string "key" "$ss_quic_key"

			if [ -n "$ss_quic_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_quic_header_type"
				json_close_object # header
			fi

			json_close_object # quicSettings
			;;
	esac

	json_add_object "sockopt"

	if [ -n "$port" ] && [ "x$port" = "x$TRANSPARENT_PROXY_PORT" ] ; then
		if [ "x$TRANSPARENT_PROXY_USE_TPROXY" = "x1" ] ; then
			json_add_string "tproxy" "tproxy"
		else
			json_add_string "tproxy" "redirect"
		fi
	else
		test -n "$ss_sockopt_tcp_fast_open" && \
			json_add_boolean "tcpFastOpen" "$ss_sockopt_tcp_fast_open"
		test -n "$ss_sockopt_tproxy" && \
			json_add_string "tproxy" "$ss_sockopt_tproxy"
	fi

	json_close_object # sockopt

	json_close_object # streamSettings

	test -n "$tag" && \
		json_add_string "tag" "$tag"

	json_add_object "sniffing"

	json_add_boolean "enabled" "$sniffing_enabled"
	if [ -n "$sniffing_dest_override" ] ; then
		json_add_array "destOverride"
		if [ "x$FAKEDNS_ENABLED" = "x1" ] ; then
			if [ "x$metadata_only" = "x1" ] ; then
				local d
				for d in $sniffing_dest_override ; do
					if [ "$d" = "fakedns" ] ; then
						json_add_string "" "$d"
					fi
				done
			else
				local d
				for d in $sniffing_dest_override ; do
					json_add_string "" "$d"
				done
			fi
			json_close_array
			json_add_boolean "metadataOnly" "$metadata_only"
		else
			local d
			for d in $sniffing_dest_override ; do
				json_add_string "" "$d"
			done
			json_close_array
			json_add_boolean "metadataOnly" "$metadata_only"
		fi
		
		
#		json_close_array # destOverride
		
	fi
	if [ -n "$domains_excluded" ] ; then
		json_add_array "domainsExcluded"
		local de
		for de in $domains_excluded ; do
			json_add_string "" "$de"
		done
		json_close_array
	fi

	json_add_boolean "routeOnly" "$route_only"

	json_close_object # sniffing

	if [ -n "$allocate_strategy" ] ; then
		json_add_object "allocate"
		json_add_string "strategy" "$allocate_strategy"
		test -n "$allocate_refresh" && \
			json_add_int "refresh" "$allocate_refresh"
		test -n "$allocate_concurrency" &&	\
			json_add_int "concurrency" "$allocate_concurrency"
		json_close_object # allocate
	fi

	json_close_object
}

add_outbound_setting() {
	local section="$1"

	if ! outbound_section_validate "$section" ; then
		_err "Invalid outbound section: $section"
		return 1
	fi

	json_add_object ""
	
	test -n "$tag" && json_add_string "tag" "$tag"

	test -n "$send_through" && \
		json_add_string "sendThrough" "$send_through"
	json_add_string "protocol" "$protocol"

	case "${protocol:-x}" in
		"blackhole")
			json_add_object "settings"

			if [ -n "$s_blackhole_reponse_type" ] ; then
				json_add_object "response"
				json_add_string "type" "$s_blackhole_reponse_type"
				json_close_object # response
			fi

			json_close_object # settings
			;;
		"dns")
			json_add_object "settings"

			test -n "$s_dns_network" && \
				json_add_string "network" "$s_dns_network"

			if [ -n "$s_dns_address" ] ; then
				json_add_string "address" "$s_dns_address"
				append_server_address "$s_dns_address"
			fi

			test -n "$s_dns_port" && \
				json_add_int "port" "$s_dns_port"

			test -n "$s_dns_non_ip_query" && \
				json_add_string "nonIPQuery" "$s_dns_non_ip_query" 

			json_close_object # settings
			;;
		"freedom")
			json_add_object "settings"

			test -n "$s_freedom_domain_strategy" && \
				json_add_string "domainStrategy" "$s_freedom_domain_strategy"
			test -n "$s_freedom_redirect" && \
				json_add_string "redirect" "$s_freedom_redirect"
			if [ -n "$s_freedom_fragment_length" ] && [ -n "$s_freedom_fragment_interval" ] ; then
				json_add_object "fragment"
				json_add_string "length" "$s_freedom_fragment_length"
				json_add_string "interval" "$s_freedom_fragment_interval"
				json_add_string  "packets" "$s_freedom_fragment_packets"
				json_close_object
			fi

			test -n "$s_freedom_user_level" && \
				json_add_int "userLevel" "$s_freedom_user_level"

			json_close_object # settings
			;;
		"http")
			json_add_object "settings"
			json_add_array "servers"

			json_add_object ""

			json_add_string "address" "$s_http_address"
			append_server_address "$s_http_address"

			test -n "$s_http_server_port" && \
				json_add_int "port" "$s_http_server_port"

			if [ -n "$s_http_account_user" ] ; then
				json_add_array "users"
				json_add_object ""

				json_add_string "user" "$s_http_account_user"
				json_add_string "pass" "$s_http_account_pass"

				json_close_object
				json_close_array # users
			fi
			json_close_object

			json_close_array # servers
			
			if [ -n "$s_http_headers" ] ; then
				json_add_object "headers"
				handle_http_header() {
					local h="$1"

					local name="$(echo "$h" | cut -d'=' -f1)"
					local value="$(echo "$h" | cut -d'=' -f2)"

					if [ -n "$name" ] && [ -n "$value" ] ; then
						json_add_string "$name" "$value"
					fi
				}
				config_list_foreach "$section" "s_http_headers" handle_websocket_header

				json_close_object # headers
			fi
			json_close_object # settings
			;;
		"loopback")
			json_add_object "settings"
			
			if [ -n "$s_loopback_inboundtag" ] ; then
				json_add_string "inboundTag" "$s_loopback_inboundtag"
			fi
			json_close_object
			;;
		"mtproto")
			json_add_object "settings"
			json_close_object
			;;
		"shadowsocks")
			json_add_object "settings"
			json_add_array "servers"

			json_add_object ""
			test -n "$s_shadowsocks_email" && \
				json_add_string "email" "$s_shadowsocks_email"
			json_add_string "address" "$s_shadowsocks_address"
			append_server_address "$s_shadowsocks_address"

			json_add_int "port" "$s_shadowsocks_port"
			json_add_string "method" "$s_shadowsocks_method"
			json_add_string "password" "$s_shadowsocks_password"

			test -n "$s_shadowsocks_level" && \
				json_add_int "level" "$s_shadowsocks_level"
			json_add_boolean "ota" "$s_shadowsocks_ota"
			json_close_object

			json_close_array # servers
			json_close_object # settings
			;;
		"socks")
			json_add_object "settings"
			json_add_array "servers"

			json_add_object ""

			json_add_string "address" "$s_socks_server_address"
			append_server_address "$s_socks_server_address"

			json_add_int "port" "$s_socks_server_port"

			if [ -n "$s_socks_account_user" ] ; then
				json_add_array "users"
				json_add_object ""

				json_add_string "user" "$s_socks_account_user"
				json_add_string "pass" "$s_socks_account_pass"

				test -n "$s_socks_user_level" && \
					json_add_int "level" "$s_socks_user_level"

				json_close_object
				json_close_array # users
			fi

			json_close_object

			json_close_array # servers
			json_close_object # settings
			;;
		"trojan")
			json_add_object "settings"
			json_add_array "servers"
			json_add_object ""
			json_add_string "address" "$s_trojan_address"
			json_add_int "port" "$s_trojan_port"
			json_add_string "password" "$s_trojan_password"
			if [ -n "$s_xtls_flow" ] ; then
				case "$ss_security" in 
					"xtls")
						if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] ; then
							if [ "$s_xtls_flow" != "xtls-rprx-vision" ] && [ "$s_xtls_flow" != "xtls-rprx-vision-udp443" ] ; then
								json_add_string "flow" "$s_xtls_flow"
							fi
						fi
						;;
					"tls")
						if [ "x$XTLS_REALITY" = "x1" ] ; then
							if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] ; then
								if [ "$s_xtls_flow" = "xtls-rprx-vision" ] || [ "$s_xtls_flow" = "xtls-rprx-vision-udp443" ] ; then
									json_add_string "flow" "$s_xtls_flow"
								fi
							fi
						fi
						;;
					"reality")
						if [ "x$XTLS_REALITY" = "x1" ] ; then
							if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] || [ "$ss_network" = "grpc" ] ; then
								if [ "$s_xtls_flow" = "xtls-rprx-vision" ] || [ "$s_xtls_flow" = "xtls-rprx-vision-udp443" ] ; then
									json_add_string "flow" "$s_xtls_flow"
								fi
							fi
						fi
						;;
				esac
			fi 
			json_close_object
			json_close_array
			 json_close_object
				;;
		"vless")
			json_add_object "settings"
			json_add_array "vnext"
			json_add_object ""
			json_add_string "address" "$s_vless_address"
			append_server_address "$s_vless_address"
			json_add_int "port" "$s_vless_port"
			json_add_array "users"
			json_add_object ""
			json_add_string "id" "$s_vless_user_id"
			if [ -n "$s_xtls_flow" ] ; then
				case "$ss_security" in 
					"xtls")
						if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] ; then
							if [ "$s_xtls_flow" != "xtls-rprx-vision" ] && [ "$s_xtls_flow" != "xtls-rprx-vision-udp443" ] ; then
								json_add_string "flow" "$s_xtls_flow"
							fi
						fi
						;;
					"tls")
						if [ "x$XTLS_REALITY" = "x1" ] ; then
							if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] ; then
								if [ "$s_xtls_flow" = "xtls-rprx-vision" ] || [ "$s_xtls_flow" = "xtls-rprx-vision-udp443" ] ; then
									json_add_string "flow" "$s_xtls_flow"
								fi
							fi
						fi
						;;
					"reality")
						if [ "x$XTLS_REALITY" = "x1" ] ; then
							if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] || [ "$ss_network" = "grpc" ] ; then
								if [ "$s_xtls_flow" = "xtls-rprx-vision" ] || [ "$s_xtls_flow" = "xtls-rprx-vision-udp443" ] ; then
									json_add_string "flow" "$s_xtls_flow"
								fi
							fi
						fi
						;;
				esac
			fi 
			test -n "$s_vless_user_level" && \
				json_add_int "level" "$s_vless_user_level"
			json_add_string "encryption" "$s_vless_user_encryption"
			json_close_object
			json_close_array # users
			json_close_object
			json_close_array # vnext
			json_close_object # settings
			;;
		"vmess")
			json_add_object "settings"

			json_add_array "vnext"
			json_add_object ""

			json_add_string "address" "$s_vmess_address"
			append_server_address "$s_vmess_address"

			json_add_int "port" "$s_vmess_port"

			json_add_array "users"
			json_add_object ""
			json_add_string "id" "$s_vmess_user_id"
			json_add_int "alterId" "$s_vmess_user_alter_id"
			test -n "$s_vmess_user_security" && \
				json_add_string "security" "$s_vmess_user_security"
			test -n "$s_vmess_user_level" && \
				json_add_int "level" "$s_vmess_user_level"
			json_close_object
			json_close_array # users

			json_close_object

			json_close_array # vnext
			json_close_object # settings
			;;
		"wireguard")
			json_add_object "settings"
			json_add_string "secretKey" "$s_wireguard_secret_key"
			if [ -n "$s_wireguard_address" ] ; then
				json_add_array "address"
				local tun_addr
				for tun_addr in $s_wireguard_address ; do
					json_add_string "" "$tun_addr"
				done
				json_close_array
			fi
			json_add_array "peers"
			json_add_object
			json_add_string "publicKey" "$s_wireguard_public_key"
			test -n $s_wireguard_preshared_key && \
				json_add_string "preSharedKey" "$s_wireguard_preshared_key"
			if [ -n "$s_wireguard_allowed_ips" ] ; then
				json_add_array "allowedIPs"
				local a_ips
				for a_ips in $s_wireguard_allowed_ips ; do
					json_add_string "" "$a_ips"
				done
				json_close_array
			fi
			test -n $s_wireguard_keep_alive && \
				json_add_int "keepAlive" "$s_wireguard_keep_alive"
			json_add_string "endpoint"  "$s_wireguard_endpoint"
			json_close_object
			json_close_array
			test -n "$s_wireguard_mtu" && \
				json_add_int "mtu" "$s_wireguard_mtu"
			if [ -n "$s_wireguard_reserved_bytes" ] ; then
				json_add_array "reserved"
				local OLD_IFS=$IFS
				IFS=","
				local rb
				for rb in $s_wireguard_reserved_bytes ; do
					json_add_int "" "$rb"
				done
				IFS=$OLD_IFS
				json_close_array
			fi
			json_close_object
			;;
	esac
	if [ "$protocol" != "wireguard" ] ; then
	json_add_object "streamSettings"
	test -n "$ss_network" && \
		json_add_string "network" "$ss_network"

	#test -n "$ss_security" && \
	case "${ss_security:-x}" in
		"tls" | "xtls")
			if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] ; then
				if [ "$ss_security" = "xtls" ] ; then 
					if [ "$protocol" = "vless" ] || [ "$protocol" = "trojan" ]  ; then
						json_add_string "security" "xtls"
						json_add_object "xtlsSettings"
					else
						json_add_string "security" "tls"
						json_add_object "tlsSettings"
					fi
				else
					json_add_string "security" "tls"
					json_add_object "tlsSettings"
				fi
			else
				json_add_string "security" "tls"
				json_add_object "tlsSettings"
			fi
				test -n "$ss_tls_server_name" && \
					json_add_string "serverName" "$ss_tls_server_name"
				if [ -n "$ss_tls_alpn" ] ; then
					json_add_array "alpn"
					local al
					for al in $ss_tls_alpn ; do
						json_add_string "" "$al"
					done
					json_close_array # destOverride
				fi
				if [ -n "$ss_reality_fingerprint" ] ; then
					json_add_string "fingerprint" "$ss_reality_fingerprint"
				fi
				json_add_boolean "allowInsecure" "$ss_tls_allow_insecure"
				json_add_boolean "allowInsecureCiphers" "$ss_tls_allow_insecure_ciphers"
				json_add_boolean "disableSystemRoot" "$ss_tls_disable_system_root"
				if [ -n "$ss_tls_cert_fiile" ] ; then
					json_add_array "certificates"
						json_add_object ""
						json_add_string "certificateFile" "$ss_tls_cert_fiile"
						json_add_string "keyFile" "$ss_tls_key_file"
						test -n "$ss_tls_cert_usage" && \
							json_add_string "usage" "$ss_tls_cert_usage"
						json_close_object
					json_close_array # certificates
				fi
				json_close_object # tlsSettings
			;;
		"reality")
			if [ "x$XTLS_REALITY" = "x1" ] ; then
				if [ "$ss_network" = "tcp" ] || [ "$ss_network" = "kcp" ] || [ "$ss_network" = "domainsocket" ] || [ "$ss_network" = "grpc" ] || [ "$ss_network" = "h2" ] ; then
					json_add_string "security" "$ss_security"
					json_add_object "realitySettings"
					json_add_boolean "show" "$ss_reality_show"
					if [ -n "$ss_reality_fingerprint" ] ; then
						json_add_string "fingerprint" "$ss_reality_fingerprint"
					fi
					json_add_string "serverName" "$ss_reality_server_name"
					json_add_string "publicKey" "$ss_reality_public_key"
					if [ -n "$ss_reality_short_id" ] ; then
						json_add_string "shortId" "$ss_reality_short_id"
					fi
					if [ -n "$ss_reality_spiderx" ] ; then
						json_add_string "spiderX" "$ss_reality_spiderx"
					fi
					json_close_object
				else
					json_add_string "security" "none"
				fi
			else
				json_add_string "security" "none"
			fi
			;;
		"*")
			json_add_string "security" "none"
			;;
	esac
	case "${ss_network:-x}" in
		"tcp")
			json_add_object "tcpSettings"

			if [ -n "$ss_tcp_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_tcp_header_type"

				if [ "$ss_tcp_header_type" = "http" ] ; then
					json_add_object "request"
					test -n "$ss_tcp_header_request_version" && \
						json_add_string "version" "$ss_tcp_header_request_version"
					json_add_string "method" "$ss_tcp_header_request_method"

					if [ -n "$ss_tcp_header_request_path" ] ; then
						json_add_array "path"
						json_add_string "" "$ss_tcp_header_request_path"
						json_close_array
					fi

					if [ -n "$ss_tcp_header_request_headers" ] ; then
						json_add_object "headers"

						handle_request_header() {
							local h="$1"

							local name="$(echo "$h" | cut -d'=' -f1)"
							local value="$(echo "$h" | cut -d'=' -f2)"

							if [ -n "$name" ] && [ -n "$value" ] ; then
								json_add_array "$name"
								json_add_string "" "$value"
								json_close_array
							fi
						}
						config_list_foreach "$section" "ss_tcp_header_request_headers" handle_request_header

						json_close_object # headers
					fi

					json_close_object # request

					json_add_object "response"
					test -n "$ss_tcp_header_response_version" && \
						json_add_string "version" "$ss_tcp_header_response_version"
					test -n "$ss_tcp_header_response_status" && \
						json_add_string "status" "$ss_tcp_header_response_status"
					test -n "$ss_tcp_header_response_reason" && \
						json_add_string "reason" "$ss_tcp_header_response_reason"

					if [ -n "$ss_tcp_header_response_headers" ] ; then
						json_add_object "headers"

						handle_response_header() {
							local h="$1"

							local name="$(echo "$h" | cut -d'=' -f1)"
							local value="$(echo "$h" | cut -d'=' -f2)"

							if [ -n "$name" ] && [ -n "$value" ] ; then
								json_add_array "$name"
								json_add_string "" "$value"
								json_close_array
							fi
						}
						config_list_foreach "$section" "ss_tcp_header_response_headers" handle_response_header

						json_close_object # headers
					fi

					json_close_object # response
				fi

				json_close_object # header
			fi

			json_close_object # tcpSettings
			;;
		"kcp")
			json_add_object "kcpSettings"

			test -n "$ss_kcp_mtu" && \
				json_add_int "mtu" "$ss_kcp_mtu"
			test -n "$ss_kcp_tti" && \
				json_add_int "tti" "$ss_kcp_tti"
			test -n "$ss_kcp_uplink_capacity" && \
				json_add_int "uplinkCapacity" "$ss_kcp_uplink_capacity"
			test -n "$ss_kcp_downlink_capacity" && \
				json_add_int "downlinkCapacity" "$ss_kcp_downlink_capacity"

			json_add_boolean "congestion" "$ss_kcp_congestion"

			test -n "$ss_kcp_read_buffer_size" && \
				json_add_int "readBufferSize" "$ss_kcp_read_buffer_size"
			test -n "$ss_kcp_write_buffer_size" && \
				json_add_int "writeBufferSize" "$ss_kcp_write_buffer_size"

			if [ -n "$ss_kcp_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_kcp_header_type"
				json_close_object
			fi

			json_close_object # kcpSettings
			;;
		"ws")
			json_add_object "wsSettings"

			test -n "$ss_websocket_path" && \
				json_add_string "path" "$ss_websocket_path"

			if [ -n "$ss_websocket_headers" ] ; then
				json_add_object "headers"
				json_add_string "Host" "$ss_websocket_headers"
#				handle_websocket_header() {
#					local h="$1"
#					local name="$(echo "$h" | cut -d'=' -f1)"
#					local value="$(echo "$h" | cut -d'=' -f2)"
#					if [ -n "$name" ] && [ -n "$value" ] ; then
#						json_add_string "$name" "$value"
#					fi
#				}
#				config_list_foreach "$section" "ss_websocket_headers" handle_websocket_header
				json_close_object # headers
			fi

			json_close_object # wsSettings
			;;
		"grpc")
			json_add_object "grpcSettings"

			test -n "$ss_grpc_service_name" && \
				json_add_string "serviceName" "$ss_grpc_service_name"
			json_add_boolean "multiMode" "$ss_grpc_multi_mode"
			json_add_boolean "permit_without_stream" "$ss_grpc_permit_without_stream"

			if [ "x$ss_grpc_permit_without_stream" = "x1" ] ; then
				test -n "$ss_grpc_health_check_timeout" && \
				json_add_int "health_check_timeout" "$ss_grpc_health_check_timeout"
			fi

			test -n "$ss_grpc_idle_timeout" && \
				json_add_int "idle_timeout" "$ss_grpc_idle_timeout"
			
			test -n "$ss_grpc_initial_windows_size" && \
				json_add_int "initial_windows_size" "$ss_initial_windows_size"
			json_close_object # wsSettings
			;;
		"h2")
			json_add_object "h2Settings"

			if [ -n "$ss_http_host" ] ; then
				json_add_array "host"

				local h
				for h in $ss_http_host ; do
					json_add_string "" "$h"
				done

				json_close_array # host
			fi

			test -n "$ss_http_path" && \
				json_add_string "path" "$ss_http_path"

			json_close_object # httpSettings
			;;
		"domainsocket")
			json_add_object "dsSettings"

			test -n "$ss_domainsocket_path" && \
				json_add_string "path" "$ss_domainsocket_path"

			json_close_object # dsSettings
			;;
		"quic")
			json_add_object "quicSettings"

			test -n "$ss_quic_security" && \
				json_add_string "security" "$ss_quic_security"
			test -n "$ss_quic_key" && \
				json_add_string "key" "$ss_quic_key"

			if [ -n "$ss_quic_header_type" ] ; then
				json_add_object "header"
				json_add_string "type" "$ss_quic_header_type"
				json_close_object # header
			fi

			json_close_object # quicSettings
			;;
	esac

	json_add_object "sockopt"

	if [ "$protocol" != "blackhole" ] && [ "$protocol" != "freedom" ] && [ "$protocol" != "dns" ]  ; then
		test -n "$ss_sockopt_domain_strategy" && \
			json_add_string "domainStrategy" "$ss_sockopt_domain_strategy"
	fi

	if [ "$protocol" = "freedom" ] ; then
		if [ -n "$s_freedom_fragment_length" ] && [ -n "$s_freedom_fragment_interval" ] && [ -n "$s_freedom_fragment_packets" ] ; then
			json_add_boolean "tcpNoDelay" "$ss_sockopt_tcp_no_delay"
		fi
	fi

	test -n "$ss_sockopt_dialer_proxy" && \
		json_add_string "dialerProxy" "$ss_sockopt_dialer_proxy"

	test -n "$ss_sockopt_tcp_congestion" && \
		json_add_string "tcpcongestion" "$ss_sockopt_tcp_congestion"

	if [ -n "$TRANSPARENT_PROXY_PORT" ] ; then
		json_add_int "mark" "255"
	else
		test -n "$ss_sockopt_mark" && \
			json_add_int "mark" "$ss_sockopt_mark"
	fi

	test -n "$ss_sockopt_tcp_fast_open" && \
		json_add_boolean "tcpFastOpen" "$ss_sockopt_tcp_fast_open"

	json_close_object # sockopt

	json_close_object # streamSettings

	if [ "x$mux_enabled" = "x1" ] ; then
		json_add_object "mux"
		json_add_boolean "enabled" "1"
		json_add_int "concurrency" "$mux_concurrency"
		if [ "$XTLS_REALITY" = "1" ] ; then
			test -n "xudp_concurrency" && \
				json_add_int "xudpConcurrency" "$xudp_concurrency"
			json_add_string "xudpProxyUDP443" "$xudp_proxy_udp443"
		fi
		json_close_object # mux
	fi
	fi
	if [ -n "$proxy_settings_tag" ] ; then
		json_add_object "proxySettings"
		json_add_string "tag" "$proxy_settings_tag"
		json_close_object # proxySettings
	fi
	json_close_object
}

init_transparent_proxy() {
	local tp_cfg="main_transparent_proxy"
	local redirect_port use_tproxy redirect_udp redirect_dns ipv6_tproxy

	config_get redirect_port "$tp_cfg" "redirect_port"
	config_get_bool use_tproxy "$tp_cfg" "use_tproxy" "0"
	config_get_bool redirect_udp "$tp_cfg" "redirect_udp" "0"
	config_get_bool redirect_dns "$tp_cfg" "redirect_dns" "0"
	config_get_bool ipv6_tproxy "$tp_cfg" "ipv6_tproxy" "0"
	if [ -n "$redirect_port" ] && \
		! validate_data "port" "$redirect_port" 2>/dev/null ; then
		_err "Transparent proxy redirect port is invalid: $redirect_port"
		return 1
	fi

	TRANSPARENT_PROXY_PORT="$redirect_port"
	TRANSPARENT_PROXY_USE_TPROXY="$use_tproxy"
	TRANSPARENT_PROXY_IPV6="$ipv6_tproxy"

	if [ "x$redirect_udp" = "x1" ] ; then
		TRANSPARENT_PROXY_ADDITION="udp"
	elif [ "x$redirect_dns" = "x1" ] ; then
		TRANSPARENT_PROXY_ADDITION="dns"
	else
		TRANSPARENT_PROXY_ADDITION=
	fi
}

setup_transparent_proxy() {
	if [ -z "$TRANSPARENT_PROXY_PORT" ] ; then
		_info "Transparent proxy disabled."
		return 0
	fi

	if [ "x$TRANSPARENT_PROXY_EXPECTED" != "x1" ] ; then
		_info "No v2ray instance enabled, skip transparent proxy."
		return 0
	fi

	_info "Setting transparent proxy on port: $TRANSPARENT_PROXY_PORT"



	local tp_cfg="main_transparent_proxy"
	local lan_ifaces only_privileged_ports proxy_mode direct_list_dns proxy_list_dns
	local excluded_tcp_port excluded_udp_port

	config_get lan_ifaces "$tp_cfg" "lan_ifaces"
	config_get_bool only_privileged_ports "$tp_cfg" "only_privileged_ports" "0"
	config_get proxy_mode "$tp_cfg" "proxy_mode"
	config_get direct_list_dns "$tp_cfg" "direct_list_dns"
	config_get proxy_list_dns "$tp_cfg" "proxy_list_dns"
	config_get EXCLUDED_TCP_PORT "$tp_cfg" "excluded_tcp_port"
	config_get EXCLUDED_UDP_PORT "$tp_cfg" "excluded_udp_port"

	test -n "$EXCLUDED_TCP_PORT" && \
		_info "Unproxied tcp port(s): $EXCLUDED_TCP_PORT"
	
	test -n "$EXCLUDED_UDP_PORT" && \
		_info "Unproxied udp port(s): $EXCLUDED_UDP_PORT"

	_info "Transparent proxy mode: $proxy_mode"
	if [ -n "$NFT_BIN" ] ; then
		if [ "$NFT_SET" = "0" ] ; then
			_info "GFWList mode requires DNSmasq 2.87 above, TProxy reset to 'default' Mode"
		fi
	fi
	test -n "$NFT_BIN" && $NFT_BIN add table inet $NAME

	create_v2ray_ipset
	init_rules_for_listfile "$direct_list_dns" "$proxy_list_dns"

	local ext_args
	local ext_args6
	case "${proxy_mode:-default}" in
		"cn_direct")
			local chnroute="$(get_file_content "chnroute")"
			local chnroute6="$(get_file_content "chnroute6")"
			if [ -n "$chnroute" ] ; then
				$NFT_BIN add element inet v2ray $IPSET_DST_DIRECT_V4 { $(echo "$chnroute" | sed "$!s/$/,/") }
			fi

			if	[ -n "$chnroute6" ] ; then 
				$NFT_BIN add element inet v2ray $IPSET_DST_DIRECT_V6 { $(echo "$chnroute6" | sed "$!s/$/,/") }
			fi
			ext_args=
			ext_args6=

			;;
		"cn_proxy")
			local chnroute="$(get_file_content "chnroute")"
			local chnroute6="$(get_file_content "chnroute6")"
			if [ -n "$chnroute" ] ; then
				$NFT_BIN add element inet v2ray $IPSET_DST_PROXY_V4 { $(echo "$chnroute" | sed "$!s/$/,/") }
			fi

			if	[ -n "$chnroute6" ] ; then 
				$NFT_BIN add element inet v2ray $IPSET_DST_PROXY_V6 { $(echo "$chnroute6" | sed "$!s/$/,/") }
			fi
			ext_args="@$IPSET_DST_PROXY_V4"
			ext_args6="@$IPSET_DST_PROXY_V6"
			
			;;
		"gfwlist_proxy")
			local gfwlist="$(get_file_content "gfwlist")"
			if [ "$NFT_SET" = "1" ] ; then
				if [ -n "$gfwlist" ] ; then
					if [ -n "$proxy_list_dns" ] ; then
						echo "$gfwlist" | \
							sed "s|.*|server=/&/$proxy_list_dns\nnftset=/&/inet\#v2ray\#$IPSET_DST_PROXY_V4,inet\#v2ray\#$IPSET_DST_PROXY_V6|" \
							>> "$FILE_V2RAY_DNSMASQ_CACHE"
					else
						echo "$gfwlist" | \
							sed "s|.*|nftset=/&/inet\#v2ray\#$IPSET_DST_PROXY_V4,inet\#v2ray\#$IPSET_DST_PROXY_V6|" \
							>> "$FILE_V2RAY_DNSMASQ_CACHE"
					fi
					ext_args="ip daddr @$IPSET_DST_PROXY_V4"
					ext_args6="ip6 daddr @$IPSET_DST_PROXY_V6"
				else
					ext_args=
					ext_args6=
				fi
			else
				ext_args=
				ext_args6=
			fi
			;;
		*)
			ext_args=
			ext_args6=
			;;
	esac

	if [ "x$only_privileged_ports" = "x1" ] ; then
			ext_args="dport { 0 - 1023 } $ext_args"
			ext_args6="dport { 0 - 1023 } $ext_args6"
	else
			ext_args="dport { 0 - 65535 } $ext_args"
			ext_args6="dport { 0 - 65535 } $ext_args6"
	fi

	if [ -n "$(cat "$FILE_V2RAY_DNSMASQ_CACHE" | grep -v "^$" | grep -v "^#")" ] ; then
			local dir="$(dirname "$FILE_V2RAY_DNSMASQ")"
			test -d "$dir" || mkdir -p "$dir"
			cat "$FILE_V2RAY_DNSMASQ_CACHE" >"$FILE_V2RAY_DNSMASQ" 2>/dev/null
			DNSMASQ_RESTART_EXPECTED=1
	fi

	rm -f "$FILE_V2RAY_DNSMASQ_CACHE"

	local lan_devices lan_ipaddrs lan_ip6addrs

	if [ -n "$lan_ifaces" ] ; then
		. /lib/functions/network.sh

		local lan
		for lan in $lan_ifaces ; do
			local device ipaddrs ipaddr ip6addrs ip6addr
			network_get_device device "$lan"
			network_get_ipaddrs ipaddrs "$lan"
			network_get_ipaddrs6 ip6addrs "$lan"

			if [ -n "$device" ] ; then
				if [ -n "$lan_devices" ] ; then
					lan_devices="$lan_devices $device"
				else
					lan_devices="$device"
				fi
			fi
			if [ -n "$ipaddrs" ] ; then
				for ipaddr in $ipaddrs ; do
					if [ -n "$lan_ipaddrs" ] ; then
						lan_ipaddrs="$ipaddr"
					else
						lan_ipaddrs="$lan_ipaddrs $ipaddr"
					fi
				done
			fi
			
			if [ -n "$ip6addrs" ] ; then
				for ip6addr in $ip6addrs; do
					if [ -n "$lan_ip6addrs" ] ; then
						lan_ip6addrs="$lan_ip6addrs $ip6addr"
					else
						lan_ip6addrs="$ip6addr"
					fi
				done
			fi
		done
	fi
	if [ "x$TRANSPARENT_PROXY_USE_TPROXY" = "x1" ] ; then
			_info "Use TProxy to setup nftables"
			add_v2ray_nftables_tproxy_rules "$ext_args" "$ext_args6" "$lan_devices" "$lan_ipaddrs" "$lan_ip6addrs" "$proxy_mode"
	else
			add_v2ray_nftables_redirect_rules "$ext_args" "$ext_args6" "$lan_devices" "$lan_ipaddrs" "$lan_ip6addrs" "$proxy_mode"
	fi
}

clear_transparent_proxy() {
	clear_v2ray_rules

	if [ -s "$FILE_V2RAY_DNSMASQ" ] ; then
		rm -f "$FILE_V2RAY_DNSMASQ"
		DNSMASQ_RESTART_EXPECTED=1
	fi
}

start_instance() {
	local section="$1"
	local ver_info
	
	if ! v2ray_section_validate "$section" ; then
		_err "Invalid config."
		return 1
	fi

	if [ -z "$v2ray_file" ] || [ ! -s "$v2ray_file" ] ; then
		_err "Invalid V2Ray file."
		return 1
	fi

	test -x "$v2ray_file" || chmod 755 "$v2ray_file"

	ver_info="$(sh -c "$v2ray_file --version 2>/dev/null | head -n1")"
	if [ -z "$ver_info" ] ; then
		ver_info="$(sh -c "$v2ray_file version 2>/dev/null | head -n1")"
	fi
	CORE="$(echo $ver_info | awk -F' ' '{printf $1}')"
	CORE_VER="$(echo $ver_info | awk -F' ' '{printf $2}')"
	uci set v2ray.main.core=$CORE
	uci commit

	if [ "x$enabled" != "x1" ] ; then
		_info "Service disabled: $section"
		return 0
	fi
	
	if [ "$CORE" = "Xray" ] && [ "$(expr $CORE_VER \>= '1.8.0')" = "1" ] ; then
		XTLS_REALITY="1"
	else
		XTLS_REALITY="0"
	fi

	local temp_config

	if [ -n "$config_file" ] ; then
		if [ ! -s "$config_file" ] ; then
			_err "Config file not found: $config_file"
			return 1
		fi

		if ! ( eval "$v2ray_file --test --config=\"$config_file\" >/dev/null 2>&1" ) ; then
			_err "Validate config file failed: $config_file"
			return 1
		fi

		local file_content="$(cat "$config_file")"
		local config_commands="$(get_commands_from_json "$file_content")"

		local addr

		for addr in $(echo "$config_commands" | sed -n "s/^json.*'address'[[:space:]]'\([^']*\)'.*/\1/p") ; do
			append_server_address "$addr"
		done

		temp_config="$config_file"
	else
		test -d "$CONFIG_FOLDER" || mkdir -p "$CONFIG_FOLDER"

		temp_config="$CONFIG_FOLDER/v2ray.${section}.json"

		local old_ns
		json_set_namespace "$section" old_ns
		json_init

		json_add_object "log"

		test -n "$access_log" && \
			json_add_string "access" "$access_log"

		if [ -n "$loglevel" ] && [ "$loglevel" != "none" ] ; then
			json_add_string "loglevel" "$loglevel"
			json_add_string "error" "$error_log"
		fi

		json_close_object # log

		if [ "x$stats_enabled" = "x1" ] ; then
			json_add_object "stats"
			json_close_object # stats
		fi

		add_dns_settings "$section"
		if [ "x$FAKEDNS_ENABLED" = "x1" ] ; then
			json_add_array "fakedns"
			json_add_object ""
			json_add_string "ipPool" "198.18.0.0/15"
			json_add_int "poolSize" "65535"
			json_close_object
			json_add_object
			json_add_string "ipPool" "fc00::/18"
			json_add_int "poolSize" "65535"
			json_close_object
			json_close_array
		_info "Fake DNS enabled"
		fi
		 
		add_routing_settings "$section"
		add_policy_settings "$section"
		add_reverse_settings "$section"

		if [ "x$transport_enabled" = "x1" ] ; then
			add_transport_settings
		fi

		if [ -n "$inbounds" ] ; then
			json_add_array "inbounds"

			local is
			for is in $inbounds ; do
				add_inbound_setting "$is"
			done

			json_close_array # inbounds
		fi

		if [ -n "$outbounds" ] ; then
			json_add_array "outbounds"

			local os
			for os in $outbounds ; do
				add_outbound_setting "$os"
			done

			json_close_array # outbounds
		fi

		json_dump -i >"$temp_config"

		json_cleanup
		json_set_namespace "$old_ns"

		if [ ! -s "$temp_config" ] ; then
			_err "Error when create config file: $temp_config"
			return 1
		fi
	fi

	TRANSPARENT_PROXY_EXPECTED=1

	procd_open_instance "$NAME.$section"
	procd_set_param command "$v2ray_file"
	if [ "$CORE" = "V2Ray" ] && [ "$(expr $CORE_VER \< "5")" = "1" ] ; then
		procd_append_param command "-c=$temp_config"
	else
		procd_append_param command "run"
		procd_append_param command "-c=$temp_config"
	fi
	procd_set_param respawn

	if [ -n "$asset_location" ] && [ -d "$asset_location" ] ; then
		procd_set_param env V2RAY_LOCATION_ASSET="$asset_location"
		procd_set_param env XRAY_LOCATION_ASSET="$asset_location"
	fi

	# cat /proc/PID/limits to see if limits works
	procd_set_param limits nofile="102400 102400"
	procd_append_param limits core="0 0"

	if [ "$mem_percentage" -gt "0" ] ; then
		local mem_total="$(awk '/MemTotal/ {print $2}' /proc/meminfo)"
		if [ -n "$mem_total" ] ; then
			local use_mem="$(expr $mem_total \* $mem_percentage \* 10)"
			procd_append_param limits as="$use_mem $use_mem"
		fi
	fi

	procd_set_param file "$temp_config"
	procd_set_param stderr 1 # forward stderr of the command to logd
	procd_set_param stdout 1
	procd_set_param pidfile "/var/run/${NAME}.${section}.pid"
	procd_close_instance
}

start_service() {
	clear_transparent_proxy

	config_load "$NAME"

	if ! init_transparent_proxy ; then
		gracefully_restart_dnsmasq
		return 1
	fi

	config_foreach start_instance "v2ray"

	setup_transparent_proxy
	gracefully_restart_dnsmasq

	unset OUTBOUND_SERVERS_V4 \
		OUTBOUND_SERVERS_V6 \
		TRANSPARENT_PROXY_EXPECTED \
		TRANSPARENT_PROXY_PORT \
		TRANSPARENT_PROXY_ADDITION \
		DNSMASQ_RESTART_EXPECTED \
		IPV6_TPROXY_ENABLED
}

stop_service() {
	if [ "x$action" = "xrestart" ] ; then
		# skip when restarting, start_service will do this
		return 0
	fi

	clear_transparent_proxy
	gracefully_restart_dnsmasq

	test -d "$CONFIG_FOLDER" && rm -rf "$CONFIG_FOLDER"
}

service_triggers() {
	procd_add_reload_trigger "$NAME"
}
